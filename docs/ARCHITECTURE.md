# Архитектура Telegram-бота с интеграцией MCP

## Обзор проекта

Этот проект представляет собой Telegram-бота, который использует различные модели больших языковых моделей (LLM) для генерации ответов с поддержкой персистентного хранения пользовательских данных. Основная цель — расширить возможности LLM, позволяя им взаимодействовать с внешними инструментами и источниками данных (MCP серверами) через Model Context Protocol (MCP), при этом сохраняя контекст диалогов и пользовательские настройки. Поддерживаются различные протоколы связи MCP (stdio, HTTP, SSE), а также полнофункциональная система управления пользователями и сессиями. Бот спроектирован как асинхронное приложение, способное эффективно обрабатывать множество одновременных запросов с сохранением состояния.

## Текущая структура файлов

*   `main.py`: Точка входа в приложение бота, отвечает за инициализацию Telegram-бота, загрузку конфигурации MCP серверов, инициализацию базы данных и их запуск/регистрацию.
*   `bot/`: Содержит логику Telegram-бота.
    *   `bot/bot.py`: Основная логика бота, обработчики команд и сообщений.
    *   `bot/callbacks.py`: Обработчики колбэков.
    *   `bot/commands.py`: Определения команд бота.
    *   `bot/handlers.py`: Обработчики сообщений.
    *   `bot/llm_utils.py`: Утилиты для работы с LLM, включая `LLMSelector`, который управляет выбором LLM и интеграцией инструментов MCP.
    *   `bot/provider_manager.py`: Управление регистрацией и выбором LLM-провайдеров.
    *   `bot/tool_manager.py`: Управление регистрацией, жизненным циклом и вызовом MCP-клиентов.
    *   `bot/utils.py`: Общие служебные функции.
*   `bot/services/`: Сервисы для работы с данными пользователей (**реализовано**).
    *   `bot/services/user_service.py`: Управление пользователями и их настройками.
    *   `bot/services/history_service.py`: Управление историей сообщений и сессиями диалогов.
*   `bot/database/`: Компоненты для работы с базой данных (**реализовано**).
    *   `bot/database/models.py`: SQLAlchemy модели для пользователей, сессий и сообщений.
    *   `bot/database/database.py`: Настройка подключения к базе данных с async поддержкой.
    *   `bot/database/migrations/`: Миграции схемы базы данных.
*   `migrate.py`: Скрипт управления миграциями базы данных.
*   `data/`: Директория для хранения данных (**реализовано**).
    *   `data/bot.db`: SQLite база данных с пользовательскими данными.
*   `llm/`: Содержит интерфейсы и реализации для различных провайдеров LLM.
    *   `llm/api.py`: Абстрактный базовый класс `LLMClient` и определения типов для ответов LLM, включая запросы на вызов инструментов.
    *   `llm/google.py`: Реализация клиента для Google Gemini с поддержкой function calling и обработкой MapComposite аргументов.
    *   `llm/ollama.py`: Реализация клиента для Ollama LLM.
    *   `llm/openai.py`: Реализация клиента для OpenAI LLM.
    *   `llm/shared_types.py`: Общие типы данных, используемые LLM-клиентами.
*   `mcp_client/`: Содержит клиентскую логику для взаимодействия с MCP серверами.
    *   `mcp_client/client.py`: Абстрактный базовый класс `BaseMCPClient`, а также конкретные реализации `HTTPMCPClient`, `StdioMCPClient` и `SSE_MCP_Client`. Содержит фабричную функцию для создания клиентов MCP с полной поддержкой протокола MCP 2024-11-05.
*   `config/`: Содержит файлы конфигурации.
    *   `config/mcp_servers.json`: Конфигурация для динамической регистрации MCP серверов.
*   `data/`: Директория для хранения данных (**планируется**).
    *   `data/bot.db`: SQLite база данных с пользовательскими данными.

## Ключевые архитектурные принципы

1.  **Модульность:** Логика разделена на независимые модули (`bot`, `llm`, `mcp_client`, `config`), что упрощает понимание, тестирование и поддержку кода.
2.  **Абстракции:** Использование абстрактных базовых классов (`BaseMCPClient`, `LLMClient`) позволяет легко добавлять новые реализации (например, новые LLM-провайдеры или типы MCP-клиентов) без изменения основной логики бота.
3.  **Асинхронность:** Последовательное использование `asyncio` для обработки I/O-bound операций (взаимодействие с Telegram API, LLM API, MCP-серверами, подпроцессами) обеспечивает высокую производительность и отзывчивость бота.
4.  **ReAct-подобный паттерн:** Реализована логика, позволяющая LLM динамически выбирать и вызывать внешние инструменты (MCP-серверы) для получения информации или выполнения действий, а затем использовать результаты этих вызовов для формирования окончательного ответа пользователю.

## Компоненты системы

### LLMSelector (`bot/llm_utils.py`)

Центральный компонент для управления LLM и их взаимодействием с инструментами.
*   **Ответственность:** Координация между ProviderManager и ToolManager, выполнение многошагового ReAct-цикла для обработки запросов пользователей с использованием MCP инструментов.
*   **Текущая реализация:** Использует `ProviderManager` для управления LLM провайдерами и `ToolManager` для управления MCP клиентами. Реализует логику многошагового вызова инструментов с ограничением итераций.

### ProviderManager (`bot/provider_manager.py`)

Управление регистрацией и выбором LLM-провайдеров.
*   **Ответственность:** Регистрация доступных LLM провайдеров, управление текущим выбранным провайдером и моделью, получение экземпляров провайдеров.
*   **Поддерживаемые провайдеры:** Google Gemini, OpenAI, Ollama с возможностью легкого добавления новых.

### ToolManager (`bot/tool_manager.py`)

Управление регистрацией, жизненным циклом и вызовом MCP-клиентов.
*   **Ответственность:** Регистрация MCP серверов, получение списка доступных инструментов, выполнение инструментов, управление stderr задачами для stdio процессов.
*   **Особенности:** Автоматическая коррекция аргументов (например, 'q' → 'query' для brave_web_search), обработка различных форматов ответов MCP серверов.

### Сервисы данных (**реализовано**)

#### UserService (`bot/services/user_service.py`)
*   **Ответственность:** Управление пользователями, их настройками LLM, персонализацией ответов.
*   **Функции:** Создание/обновление пользователей, сохранение выбора провайдера и модели, управление настройками персонализации.
*   **Реализованные методы:** `get_or_create_user()`, `update_llm_settings()`, `update_personalization()`, `get_user_settings()`

#### HistoryService (`bot/services/history_service.py`)
*   **Ответственность:** Управление историей сообщений для контекста LLM и сессиями диалогов.
*   **Функции:** Сохранение сообщений, получение истории для LLM, управление сессиями, очистка истории.
*   **Реализованные методы:** `save_message()`, `get_conversation_history()`, `clear_history()`, `get_session_stats()`
*   **Особенности:** Автоматическое создание сессий, ограничения по времени и количеству сообщений, поддержка метаданных.

### LLMClient (`llm/api.py` и реализации)

Интерфейс для взаимодействия с различными провайдерами LLM.
*   **Ответственность:** Отправка запросов к конкретным LLM (OpenAI, Google, Ollama) и получение их ответов.
*   **Возвращаемые типы:** Метод `generate_response` возвращает `LLMResponse`, который может быть либо обычным текстовым ответом, либо структурированным запросом на выполнение инструмента (`ToolCall`).

### MCPClient (`mcp_client/client.py`)

Полнофункциональная реализация клиента Model Context Protocol 2024-11-05.
*   **`BaseMCPClient`:** Абстрактный базовый класс, определяющий общий интерфейс для всех MCP клиентов с методами `list_tools`, `execute_tool`, `list_resources`, `access_resource`.
*   **`HTTPMCPClient`:** Реализация для взаимодействия с MCP серверами по протоколу HTTP. Использует библиотеку `httpx` для надежных асинхронных запросов.
*   **`StdioMCPClient`:** Реализация для взаимодействия с MCP серверами через стандартные потоки ввода/вывода (stdin/stdout). Включает:
    *   Правильный MCP handshake с initialize/initialized
    *   Управление жизненным циклом подпроцесса MCP сервера
    *   JSON-RPC 2.0 протокол с корректными методами (tools/list, tools/call, resources/list, resources/read)
    *   Асинхронное чтение ответов и обработка уведомлений
*   **`SSE_MCP_Client`:** Реализация для Server-Sent Events транспорта с поддержкой real-time уведомлений.
*   **Фабрика клиентов:** Автоматический выбор и создание соответствующего типа `MCPClient` на основе конфигурации сервера.

### Модели данных (**реализовано**)

#### User Model
```python
class User(Base):
    user_id: int (Primary Key)
    telegram_id: int (Unique)
    username: str
    first_name: str
    last_name: str
    llm_provider: str (default: 'google')
    llm_model: str (default: 'gemini-2.5-flash')
    response_style: str (default: 'balanced')
    max_history_messages: int (default: 20)
    language: str (default: 'ru')
    created_at: datetime
    updated_at: datetime
    last_activity: datetime
```

#### Session Model
```python
class Session(Base):
    id: int (Primary Key)
    user_id: int (Foreign Key)
    is_active: bool (default: True)
    created_at: datetime
    ended_at: datetime (nullable)
```

#### Message Model
```python
class Message(Base):
    id: int (Primary Key)
    user_id: int (Foreign Key)
    session_id: int (Foreign Key)
    message_type: str ('user', 'assistant', 'system', 'tool_call', 'tool_result')
    role: str (для совместимости с OpenAI API)
    content: str
    message_metadata: JSON (модель, токены, время выполнения, MCP инструменты)
    tokens_used: int (default: 0)
    processing_time_ms: int (default: 0)
    created_at: datetime
```

### Поток выполнения запроса с использованием инструментов MCP

```mermaid
graph TD
    A[Пользователь отправляет сообщение] --> B{Бот получает сообщение};
    B --> C[LLMSelector.generate_response вызывается];
    C --> D[LLMSelector получает доступные инструменты MCP];
    D --> E[Промпт с инструментами отправляется в LLM];
    E --> F{LLM генерирует ответ};
    F -- Если LLM запрашивает инструмент --> G[Бот распознает запрос инструмента];
    G --> H{Бот выбирает тип MCPClient (HTTP/Stdio)};
    H --> I[Бот выполняет инструмент через выбранный MCPClient];
    I --> J[Результат инструмента возвращается боту];
    J --> K[Результат инструмента передается обратно в LLM];
    K --> L[LLM генерирует окончательный ответ];
    F -- Если LLM дает прямой ответ --> L;
    L --> M[Бот отправляет ответ пользователю];
```

## Дальнейшие улучшения и стратегическое развитие

### Реализованные улучшения ✅
1.  **Многошаговый вызов инструментов:** Реализован ReAct-цикл с ограничением итераций (MAX_TOOL_CALL_ITERATIONS = 3), позволяющий LLM выполнять цепочки действий для решения сложных задач.
2.  **Декомпозиция LLMSelector:** Выполнено разделение на `ProviderManager` и `ToolManager`, что улучшило архитектуру и поддерживаемость кода.
3.  **Полная поддержка MCP протокола:** Реализован корректный handshake, JSON-RPC 2.0, поддержка всех типов транспорта (stdio, HTTP, SSE).

### Планируемые улучшения 🚧

#### Фаза 1: Персистентность данных ✅ ЗАВЕРШЕНО
1.  **Система управления пользователями:** ✅
    *   Автоматическое сохранение выбора LLM провайдера и модели
    *   Персонализация стиля ответов (краткий/сбалансированный/подробный)
    *   Настройки лимита истории сообщений
2.  **История диалогов:** ✅
    *   Сохранение контекста диалогов для улучшения качества ответов
    *   Система сессий для группировки разговоров
    *   Команды управления историей (/clear, /history)
3.  **База данных SQLite с SQLAlchemy:** ✅
    *   Модели User, Session, Message
    *   Миграции схемы базы данных
    *   Сервисы для работы с данными

#### Фаза 2: Расширенная функциональность
1.  **Улучшенная персонализация:**
    *   Адаптивные промпты под стиль пользователя
    *   Мультиязычная поддержка
    *   Статистика использования и аналитика
2.  **Управление сессиями:**
    *   Именованные сессии диалогов
    *   Переключение между сессиями
    *   Экспорт истории диалогов
3.  **Расширение MCP экосистемы:**
    *   Интеграция с дополнительными MCP серверами
    *   Поддержка MCP ресурсов (не только инструментов)
    *   Кэширование результатов MCP запросов

## Текущее состояние и достижения

### Реализованные компоненты ✅

#### MCP Integration
*   **Полная поддержка протокола MCP 2024-11-05** с корректным handshake (initialize/initialized)
*   **Три типа транспорта:** stdio, HTTP, SSE с автоматическим выбором клиента
*   **Надежный StdioMCPClient** с асинхронным JSON-RPC 2.0 и управлением жизненным циклом процессов
*   **Автоматическая коррекция аргументов** для совместимости с различными LLM провайдерами
*   **Работающие интеграции:** Brave Search (web + local search) с real-time данными

#### LLM Integration  
*   **Google Gemini:** Полная поддержка function calling с обработкой MapComposite аргументов и conversation history
*   **OpenAI и Ollama:** Поддержка с conversation history и возможностью расширения
*   **Многошаговый ReAct цикл** для выполнения цепочек инструментов
*   **Улучшенные промпты** для лучшего понимания доступных инструментов

#### Database & Persistence
*   **SQLAlchemy модели** для пользователей, сессий и сообщений
*   **Асинхронная работа с базой данных** через aiosqlite
*   **Система миграций** с управляющим скриптом migrate.py
*   **UserService** для управления пользователями и настройками
*   **HistoryService** для управления историей диалогов и сессиями

#### User Experience
*   **Автоматическая регистрация команд** в меню Telegram
*   **Персистентные настройки** пользователей (провайдер, модель)
*   **Контекстные диалоги** с сохранением истории
*   **Команды управления:** /settings, /history, /clear
*   **Статистика сессий** и управление историей

#### Architecture
*   **Модульная архитектура** с разделением на ProviderManager, ToolManager, UserService, HistoryService
*   **Асинхронная обработка** всех I/O операций включая базу данных
*   **Comprehensive error handling** с логированием и graceful degradation
*   **Готовность к масштабированию** для добавления новых MCP серверов и функций

### Области для улучшения 🔧

#### Краткосрочные улучшения
1.  **Health checks для MCP серверов:** Замена фиксированных задержек на проверки готовности
2.  **Улучшение обработки больших результатов:** Сокращение/сжатие данных перед передачей в LLM
3.  **Система шаблонов промптов:** Вынос hardcoded промптов в конфигурационные файлы
4.  **Мета-инструменты:** Создание системных инструментов для самоанализа бота

#### Среднесрочные улучшения  
1.  **Кэширование MCP результатов:** Избежание повторных запросов для одинаковых данных
2.  **Расширенная обработка ошибок:** Передача ошибок инструментов обратно в LLM для retry логики
3.  **Мониторинг и метрики:** Система отслеживания производительности и использования
4.  **Конфигурационная система:** Централизованное управление настройками всех компонентов

## Реализованная система персистентности ✅

### База данных (SQLite + SQLAlchemy)

#### Система миграций
Проект включает полнофункциональную систему управления миграциями:

```bash
# Инициализация базы данных
python migrate.py init

# Проверка статуса базы данных
python migrate.py status

# Сброс базы данных (удаление всех данных)
python migrate.py reset
```

**Структура миграций:**
- `bot/database/migrations/initial_schema.py` - начальная схема
- `migrate.py` - управляющий скрипт миграций
- Поддержка как синхронных (для миграций), так и асинхронных (для приложения) сессий

#### Схема данных
```sql
-- Пользователи и настройки
CREATE TABLE users (
    user_id INTEGER PRIMARY KEY,
    username TEXT,
    first_name TEXT,
    last_name TEXT,
    llm_provider TEXT DEFAULT 'google',
    llm_model TEXT DEFAULT 'gemini-2.5-flash',
    response_style TEXT DEFAULT 'balanced',
    max_history_messages INTEGER DEFAULT 20,
    language TEXT DEFAULT 'ru',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Сессии диалогов
CREATE TABLE sessions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    session_name TEXT DEFAULT 'Диалог',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (user_id)
);

-- История сообщений
CREATE TABLE messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    session_id INTEGER,
    message_type TEXT NOT NULL,
    role TEXT NOT NULL,
    content TEXT NOT NULL,
    metadata JSON,
    tokens_used INTEGER DEFAULT 0,
    processing_time_ms INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (user_id),
    FOREIGN KEY (session_id) REFERENCES sessions (id)
);
```

### Реализованные команды бота ✅
```
/start - начать работу с ботом и показать настройки
/help - справка по командам
/select - выбрать LLM провайдера и модель
/settings - показать текущие настройки пользователя
/tools - показать доступные MCP инструменты
/history - показать статистику текущей сессии
/clear - очистить историю текущей сессии
```

### Планируемые команды 🚧
```
/style <concise|balanced|detailed> - стиль ответов  
/history_limit <число> - лимит сохраняемых сообщений
/new_session [название] - создать новую сессию
/sessions - список всех сессий
/stats - статистика использования
/export - экспорт истории диалогов
```

### Персонализация по провайдерам
Система адаптивных промптов и параметров для каждого LLM провайдера:
*   **Стили ответов:** concise, balanced, detailed
*   **Температура и max_tokens** в зависимости от стиля
*   **Системные промпты** адаптированные под провайдера

## Использование ресурсов MCP

Текущая реализация поддерживает как **инструменты** (tools), так и **ресурсы** (resources) MCP серверов:
*   **Инструменты:** Активные функции для выполнения действий (поиск, API вызовы)
*   **Ресурсы:** Статические данные для чтения (конфигурации, документы, базы знаний)

Планируется расширение использования ресурсов для:
*   Доступа к пользовательским профилям и настройкам
*   Чтения документации и справочных материалов
*   Интеграции с системами управления знаниями

## Roadmap развития

### Q1 2025: Персистентность и пользовательский опыт ✅ ЗАВЕРШЕНО
- [x] Полная интеграция MCP с поддержкой всех транспортов
- [x] SQLAlchemy модели и миграции
- [x] Сервисы для управления пользователями и сессиями
- [x] Система персонализации ответов
- [x] Команды управления историей и настройками
- [x] Автоматическая регистрация команд в Telegram
- [x] Контекстные диалоги с сохранением истории

### Q2 2025: Расширенная функциональность  
- [ ] Интеграция с дополнительными MCP серверами (GitHub, Slack, файловая система)
- [ ] Система кэширования и оптимизации производительности
- [ ] Аналитика использования и метрики
- [ ] Мультиязычная поддержка

### Q3 2025: Масштабирование и enterprise функции
- [ ] Поддержка PostgreSQL для больших нагрузок
- [ ] Система ролей и разрешений
- [ ] API для интеграции с внешними системами
- [ ] Расширенная система мониторинга и алертов
